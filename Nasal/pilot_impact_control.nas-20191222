# Pilot Impact control system for advert and resolv collision situations
#
# 2019-10-25 Adriano Bassignana
# GPL 2.0+

var prop = props.globals.initNode("fdm/jsbsim/systems/autopilot/gui/impact-control-active", 0, "INT");
var prop = props.globals.initNode("fdm/jsbsim/systems/autopilot/gui/impact-control-freeze", 1, "INT");
var prop = props.globals.initNode("fdm/jsbsim/systems/autopilot/gui/impact-min-z-ft", 200, "DOUBLE");
var prop = props.globals.initNode("fdm/jsbsim/systems/autopilot/gui/impact-medium-time", 10, "DOUBLE");

var timeStep = 1.0;
var timeStepDivisor = 1.0;
var delta_time = 1.0;

var speed_fps = 0.0; 
var speed_horz_fps = 0.0;
var speed_down_fps = 0.0;
var imp_min_z_ft = 0.0;
var imp_min_z_ft_lag = 0.0;
var imp_min_z_ft_lag_factor = 1.0;

var imp_medium_time = 0.0;
var imp_cnt_min_time = 0.0;
var imp_cnt_active = 0;
var imp_al = 0.0;

var imp_T0 = 0.0;
var imp_T1 = 0.0;
var imp_T2 = 0.0;
var imp_T3 = 0.0;

var intensity_calc = 0.0;
var intensity_calc_lag = 0.0;


var calculate_imp_geod = func(aAircraftPosition, aHeading, aSpeed_down_fps, aSpeed_horz_fps, aSpeed_fps) {
    var xyz = {"x":aAircraftPosition.x(),"y":aAircraftPosition.y(),"z":aAircraftPosition.z()};
    var end = geo.Coord.new(aAircraftPosition);
    #### end.apply_course_distance(aHeading, aSpeed_horz_fps * FT2M);
    #### end.set_alt(end.alt() - aSpeed_down_fps * FT2M);
    end.apply_course_distance(aHeading, 1.0);
    var dir_x = end.x()-aAircraftPosition.x();
    var dir_y = end.y()-aAircraftPosition.y();
    #### var dir_z = end.z()-aAircraftPosition.z();
    var dir_z = math.tan(aSpeed_down_fps * 0.0174533);
    var dir = {"x":dir_x,"y":dir_y,"z":dir_z};
    return geod = get_cart_ground_intersection(xyz, dir);
}

var calculate_imp_elev = func(aGeod) {
    if (aGeod != nil) {
        return aGeod.elevation;
    } else {
        return -1;
    }
}

var calculate_imp_time = func(aGeod, aAircraftPosition, aElevation, aSpeed_fps) {
    if (aGeod != nil and aElevation > 0.0) {
        var end = geo.Coord.new(aAircraftPosition);
        end.set_latlon(aGeod.lat, aGeod.lon, aElevation);
        var dist = aAircraftPosition.direct_distance_to(end) * M2FT;
        var time_to_impact = dist / aSpeed_fps;
        if (time_to_impact < 0.1) time_to_impact = 0.1;
        return time_to_impact;
    } else {
        return -1;
    }
}

var setIntensty_calc_lag = func(aIntensity_calc,intensity_calc_lag_incr,intensity_calc_lag_dec) {
    var incr = intensity_calc_lag_incr * delta_time;
    var dec = intensity_calc_lag_dec * delta_time;
    if (aIntensity_calc > (intensity_calc_lag + incr / 2)) {
        intensity_calc_lag = intensity_calc_lag + intensity_calc_lag_incr * delta_time;
    } else if (aIntensity_calc < (intensity_calc_lag - dec / 2)) {
        intensity_calc_lag = intensity_calc_lag - intensity_calc_lag_dec * delta_time;
    }
}


var analyze_imp_time = func() {
    
    var debugActive = getprop("fdm/jsbsim/systems/autopilot/gui/debug-active");
    
    #
    # Min time for start the anti-impact procedure
    #
    imp_medium_time = getprop("fdm/jsbsim/systems/autopilot/gui/impact-medium-time");
    imp_cnt_min_time = imp_medium_time * (1 + intensity_calc_lag) / 2.0;
    
    #
    # Min altitude
    #
    imp_min_z_ft = getprop("fdm/jsbsim/systems/autopilot/gui/impact-min-z-ft");
    
    #
    # Calculate aircraft position and velocity vector
    #
    speed_down_fps  = getprop("velocities/speed-down-fps");
    speed_horz_fps = getprop("fdm/jsbsim/systems/autopilot/speed-true-on-terrain-fps");
    speed_fps = getprop("fdm/jsbsim/systems/autopilot/speed-true-fps");
    var heading = getprop("fdm/jsbsim/systems/autopilot/heading-true-deg");
    var imp_pitch_alpha = 0.0;
    
    #
    # Situation analisys by T0 (orizontal) T1 and T2
    #
    
    var aircraftPosition = geo.aircraft_position();
    
    var geodToImpact = calculate_imp_geod(aircraftPosition, heading, 0.0, speed_horz_fps, speed_fps);
    var elevation = calculate_imp_elev(geodToImpact);
    var elevation_max = 0.0;
    var intensity = 0.0;
    var time_impact_Min = 999999.0;
    if (elevation >= 0.0) {
        imp_T0 = calculate_imp_time(geodToImpact, aircraftPosition, elevation, speed_fps);
        if (imp_T0 <= 0.0) {
            imp_T0 = 0.0;
        } else {
            intensity = intensity + 2.0 * (imp_cnt_min_time / imp_T0);
            if (time_impact_Min > imp_T0 * 0.25) time_impact_Min = imp_T0;
        }
    } else {
        imp_T0 = 0.0;
    }
    if (elevation_max < elevation and imp_T0 < imp_cnt_min_time) {
        elevation_max = elevation;
    }
    print("#### altitude-QFE-impact-elev T0: ",elevation * M2FT," T0: ",imp_T0);
    
    ### geodToImpact = calculate_imp_geod(aircraftPosition, heading, speed_down_fps, speed_horz_fps, speed_fps);
    geodToImpact = calculate_imp_geod(aircraftPosition, heading, -10.0, speed_horz_fps, speed_fps);
    elevation = calculate_imp_elev(geodToImpact);
    if (elevation >= 0.0) {
        imp_T1 = calculate_imp_time(geodToImpact, aircraftPosition, elevation, speed_fps);
        if (imp_T1 <= 0.0) {
            imp_T1 = 0.0;
        } else {
            intensity = intensity + 1.0 * (imp_cnt_min_time / imp_T1);
            if (time_impact_Min > imp_T1 * 0.5) time_impact_Min = imp_T1;
        }
    } else {
        imp_T1 = 0.0;
    }
    if (elevation_max < elevation and imp_T1 < imp_cnt_min_time) {
        elevation_max = elevation;
    }
    print("#### altitude-QFE-impact-elev T1: ",elevation * M2FT," T1: ",imp_T1);
    
    ### geodToImpact = calculate_imp_geod(aircraftPosition, heading, speed_down_fps * 2.0, speed_horz_fps, speed_fps);
    geodToImpact = calculate_imp_geod(aircraftPosition, heading, -20.0, speed_horz_fps, speed_fps);
    elevation = calculate_imp_elev(geodToImpact);
    if (elevation >= 0.0) {
        imp_T2 = calculate_imp_time(geodToImpact, aircraftPosition, elevation, speed_fps);
        if (imp_T2 <= 0.0) {
            imp_T2 = 0.0;
        } else {
            intensity = intensity + 0.5 * (imp_cnt_min_time / imp_T2);
            if (time_impact_Min > imp_T2 * 2.0) time_impact_Min = imp_T2;
        }
    } else {
        imp_T2 = 0.0;
    }
    if (elevation_max < elevation and imp_T2 < imp_cnt_min_time) {
        elevation_max = elevation;
    }
    print("#### altitude-QFE-impact-elev T2: ",elevation * M2FT," T2: ",imp_T2);
    
    ### geodToImpact = calculate_imp_geod(aircraftPosition, heading, (speed_down_fps * (-1.0)), speed_horz_fps, speed_fps);
    geodToImpact = calculate_imp_geod(aircraftPosition, heading, 20.0, speed_horz_fps, speed_fps);
    elevation = calculate_imp_elev(geodToImpact);
    if (elevation >= 0.0) {
        imp_T3 = calculate_imp_time(geodToImpact, aircraftPosition, elevation, speed_fps);
        if (imp_T3 <= 0.0) {
            imp_T3 = 0.0;
        } else {
            intensity = intensity + (imp_medium_time / 5.0) * (imp_cnt_min_time / imp_T3);
            if (time_impact_Min > imp_T3) time_impact_Min = imp_T3;
        }
    } else {
        imp_T3 = 0.0;
    }
    if (elevation_max < elevation and imp_T3 < ((imp_medium_time / 5.0) * imp_cnt_min_time)) {
        elevation_max = elevation;
    }
    print("#### altitude-QFE-impact-elev T3: ",elevation * M2FT," T3: ",imp_T3);
    
    intensity_calc = 0.5 + math.ln(1 + intensity * 0.5 * (imp_cnt_min_time / time_impact_Min));
    if (time_impact_Min > 50) {
        setIntensty_calc_lag(intensity_calc, 0.7,0.9);
    } else {
        setIntensty_calc_lag(intensity_calc, 0.7,0.3);
    }
    
    var ground_elev_m = getprop("/position/ground-elev-m");
    if (ground_elev_m != nil and elevation_max < (ground_elev_m * intensity_calc_lag)) {
        elevation_max = ground_elev_m * intensity_calc_lag;
    }
    
    setprop("fdm/jsbsim/systems/autopilot/altitude-QFE-impact-elev-ft",elevation_max * M2FT);
    setprop("fdm/jsbsim/systems/autopilot/altitude-QFE-impact-elev-intensity",intensity_calc_lag);
    setprop("fdm/jsbsim/systems/autopilot/pitch-output-error-coefficient-gain",2 * intensity_calc_lag);
    
    print("#### altitude-QFE elevation_max: ",elevation_max * M2FT, " intensity: ", intensity_calc, " | ",intensity_calc_lag," imp_cnt_min_time: ",imp_cnt_min_time," | ",time_impact_Min);
    
}


var pilot_imp_control = func() {
    
    imp_cnt_active = getprop("fdm/jsbsim/systems/autopilot/gui/impact-control-active");
    analyze_imp_time();
    
    if (imp_cnt_active == 0) {
        timeStepDivisor = 1;
    } else {
        if (intensity_calc_lag < 0.5) {
            timeStepDivisor = 5;
        } else {
            timeStepDivisor = 2;
        }
    }
    delta_time = timeStep / timeStepDivisor;
    pilot_imp_controlTimer.restart(delta_time);

}


var pilot_imp_controlTimer = maketimer(delta_time, pilot_imp_control);
pilot_imp_controlTimer.singleShot = 1;
pilot_imp_controlTimer.start();
